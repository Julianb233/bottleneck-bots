/**
 * Stress Test
 *
 * Tests system under extreme load beyond normal capacity
 * Identifies breaking points and degradation patterns
 *
 * Usage: k6 run tests/load/api-stress.test.js
 */

import http from 'k6/http';
import { check, sleep, group } from 'k6';
import { Rate, Trend, Counter, Gauge } from 'k6/metrics';
import { BASE_URL, getHeaders, ENDPOINTS, STAGES, randomInt } from './k6.config.js';

// Custom metrics
const errorRate = new Rate('errors');
const responseTime = new Trend('response_time');
const activeVUs = new Gauge('active_vus');
const requestsPerSecond = new Counter('requests_per_second');

// Test configuration - pushing system to limits
export const options = {
  stages: STAGES.stress,
  thresholds: {
    // Relaxed thresholds for stress test
    http_req_duration: ['p(95)<3000'], // 95% under 3s
    http_req_failed: ['rate<0.10'], // Up to 10% errors acceptable
    errors: ['rate<0.15'], // Up to 15% custom errors
  },
  tags: {
    testType: 'stress',
    environment: __ENV.ENVIRONMENT || 'local',
  },
  // Batch requests to increase load
  batch: 10,
  batchPerHost: 5,
};

export function setup() {
  console.log(`Running STRESS test against ${BASE_URL}`);
  console.log('WARNING: This test will push the system to its limits');

  return {
    startTime: Date.now(),
    testId: `stress-${Date.now()}`,
  };
}

export default function (data) {
  const headers = getHeaders();
  activeVUs.add(__VU);

  // Batch of concurrent requests to maximize load
  const responses = http.batch([
    ['GET', `${BASE_URL}${ENDPOINTS.health}`, null, { headers }],
    ['GET', `${BASE_URL}${ENDPOINTS.agents}`, null, { headers }],
    ['GET', `${BASE_URL}${ENDPOINTS.tasks}`, null, { headers }],
    ['GET', `${BASE_URL}${ENDPOINTS.swarm}`, null, { headers }],
  ]);

  let allSuccess = true;

  for (const res of responses) {
    responseTime.add(res.timings.duration);
    requestsPerSecond.add(1);

    const success = check(res, {
      'stress: status < 500': (r) => r.status < 500,
      'stress: response < 3s': (r) => r.timings.duration < 3000,
    });

    if (!success) {
      allSuccess = false;
    }
  }

  errorRate.add(!allSuccess);

  // Minimal think time to maximize load
  sleep(randomInt(0.1, 0.5));
}

// Additional scenario - database heavy operations
export function databaseStress() {
  const headers = getHeaders();

  // Operations that hit the database
  const dbEndpoints = [
    ENDPOINTS.knowledge,
    ENDPOINTS.memory,
    `${ENDPOINTS.tasks}?limit=100`,
  ];

  for (const endpoint of dbEndpoints) {
    const res = http.get(`${BASE_URL}${endpoint}`, { headers });

    check(res, {
      'db stress: status valid': (r) => r.status < 500,
    });

    responseTime.add(res.timings.duration);
  }

  sleep(0.5);
}

// Scenario for POST operations (writes)
export function writeStress() {
  const headers = getHeaders();

  // Create tasks (if endpoint supports it)
  const taskData = JSON.stringify({
    name: `Stress Test Task ${Date.now()}`,
    description: 'Generated by stress test',
    type: 'test',
  });

  const res = http.post(`${BASE_URL}${ENDPOINTS.tasks}`, taskData, {
    headers,
    tags: { operation: 'write' },
  });

  const success = check(res, {
    'write stress: status valid': (r) => r.status < 500,
    'write stress: response < 2s': (r) => r.timings.duration < 2000,
  });

  errorRate.add(!success);
  sleep(1);
}

export function teardown(data) {
  const duration = ((Date.now() - data.startTime) / 1000 / 60).toFixed(2);
  console.log(`Stress test completed in ${duration} minutes`);
  console.log(`Test ID: ${data.testId}`);
}

export function handleSummary(data) {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const { metrics } = data;

  // Calculate breaking point (when errors started increasing)
  const summary = {
    testType: 'stress',
    timestamp: new Date().toISOString(),
    results: {
      totalRequests: metrics.http_reqs?.values?.count || 0,
      peakRPS: metrics.http_reqs?.values?.rate || 0,
      errorRate: (metrics.errors?.values?.rate * 100) || 0,
      avgResponseTime: metrics.http_req_duration?.values?.avg || 0,
      p95ResponseTime: metrics.http_req_duration?.values?.['p(95)'] || 0,
      p99ResponseTime: metrics.http_req_duration?.values?.['p(99)'] || 0,
      maxResponseTime: metrics.http_req_duration?.values?.max || 0,
    },
  };

  return {
    [`tests/load/results/stress-${timestamp}.json`]: JSON.stringify(data, null, 2),
    [`tests/load/results/stress-summary-${timestamp}.json`]: JSON.stringify(summary, null, 2),
    stdout: generateStressSummary(data, summary),
  };
}

function generateStressSummary(data, summary) {
  const { results } = summary;

  const status = results.errorRate < 10 ? '✓ PASSED' : '✗ DEGRADED';

  return `
╔══════════════════════════════════════════════════════╗
║              STRESS TEST RESULTS                     ║
╠══════════════════════════════════════════════════════╣
║  Status: ${status.padEnd(40)}║
╠══════════════════════════════════════════════════════╣
║  Performance Metrics:                                ║
║    Total Requests:    ${results.totalRequests.toString().padEnd(28)}║
║    Peak RPS:          ${results.peakRPS.toFixed(2).padEnd(28)}║
║    Error Rate:        ${results.errorRate.toFixed(2)}%${' '.repeat(24)}║
╠══════════════════════════════════════════════════════╣
║  Response Times:                                     ║
║    Average:           ${results.avgResponseTime.toFixed(0)}ms${' '.repeat(23)}║
║    p95:               ${results.p95ResponseTime.toFixed(0)}ms${' '.repeat(23)}║
║    p99:               ${results.p99ResponseTime.toFixed(0)}ms${' '.repeat(23)}║
║    Max:               ${results.maxResponseTime.toFixed(0)}ms${' '.repeat(23)}║
╚══════════════════════════════════════════════════════╝
`;
}
